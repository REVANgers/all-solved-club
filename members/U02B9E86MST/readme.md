# Problem solving

## Language : `C++`

## Workbook : [`Baekjoon`](#baekjoon), [`Programmers`](#programmers)

## Baekjoon

> DFS+BFS 다시 풀기

1. ✅ 1260_DFS와BFS  
각 노드에서 갈 수 있는 간선을 저장하는 자료구조를 `set`으로 하고,  
모든 간선을 저장하는 자료구조를 `map`으로 해 보았다.  
그 결과 수행시간이 늘어났다.
아마 `vector` -> `set`, `map` 으로 바뀌었을 때, 삽입의 시간복잡도가  
`O(1) -> O( log(n) )` 으로 바뀌었기 때문인것으로 생각된다.

2. ✅ 2178_미로탐색  
예전과 비슷하게 구현했지만, 챌린지 기간동안에 모듈화 하는 습관을 들였기 때문에  
여기에서도 모듈화를 적용하였다. 코테를 볼 때에는 시간이 부족해서 모듈화를 하기엔 시간낭비일지도 모르겠지만,  
난이도가 있는 문제를 만나면 모듈화 하는것이 도움이 될지도..?

3. ✅ 2606_바이러스

4. ✅ 2667_단지번호붙이기

5. ✅ 2644_촌수계산

6. ✅ 7569_토마토

> 구현  

## Programmers

> 월간 코딩 챌린지

> 위클리 코딩 챌린지
> 1. ✅ 직업군 추천하기 - 4주차  
>     cpp 풀이 : map을 중첩으로 사용해서 풀었다.  
>     간단한 구현문제였지만, cpp문법이 아직 재활중이라 문법오류가 많았다.   그리고 깨끗하지 않은 풀이이다..   
>     swift로 다시 풀면서 깔끔한 풀이를 구상해야겠다.
>
> 2. ✅ 모음 사전 - 5주차
>     모든 가능한 단어를 set에 넣고 비교함수를 구현해 정렬하려는 생각으로 문제를 해결했다.
>     하지만 set에 넣는 과정에서 이미 사전순으로 정렬이 되는 바람에, 굳이 정렬을 할 필요가 없어졌다.
>     set에 넣는 순서만 잘 구현하면 되는 것 같다.
>
>   > 다른사람의 풀이를 봤을 때, `진법변환`과 같은 방법으로 구현한 것을 볼 수 있었다.
>   >
>   > 처음에 비슷한 생각을 했었지만 너무 `magic number` 같은 느낌이라서 하지 않았는데,
>   >
>   > 이런 방식으로 문제를 푸는 것도 효율적이기도 하고 특히 시간압박이 있는 코테에서는 주요한 풀이가 될 것같아서 배워놔야겠다.
>
> 3. ✅ 복서 정렬하기 - 6주차
>     딱 보자마자 `compare` 함수를 작성해서 배열을 구현하는것이 적절할 것이라고 생각했다.
>
>     생각을 그대로 옮겨서 작성했다.
>
>     승률을 비교하는 부분에서는 소숫점 부분에서 오류가 나올것을 대비해서
>
>     분모를 서로의 분자에 곱해주는 방식으로 계산함으로써 소숫점을 아예 사용하지 않을 수 있었다.
